# Retrievers

<span data-heading-keywords="retriever,retrievers"></span>

:::info[Prerequisites]

* [Vector stores](/docs/concepts/vectorstores/)
* [Embeddings](/docs/concepts/embedding_models/)
* [Text splitters](/docs/concepts/text_splitters/)

:::

## Overview

存在多种不同类型的检索系统，包括向量存储、图数据库和关系型数据库。
随着大型语言模型日益普及，检索系统已成为 AI 应用（例如 [RAG](/docs/concepts/rag/)）的重要组成部分。
鉴于其重要性和多样性，LangChain 提供了一个统一的接口来与不同类型的检索系统进行交互。
LangChain 的 [retriever](/docs/concepts/retrievers/) 接口非常简单：

1. 输入：一个查询（字符串）
2. 输出：一系列文档（标准化的 LangChain [Document](https://python.langchain.com/api_reference/core/documents/langchain_core.documents.base.Document.html) 对象）

## Key concept

![Retriever](/img/retriever_concept.png)
 
所有检索器都实现了一个简单的接口，用于使用自然语言查询来检索文档。

## Interface 

检索器的唯一要求是能够接受查询并返回文档。 
特别是，[LangChain's retriever class](https://python.langchain.com/api_reference/core/retrievers/langchain_core.retrievers.BaseRetriever.html#) 只要求实现 `_get_relevant_documents` 方法，该方法接受一个 `query: str` 并返回一个 [Document](https://python.langchain.com/api_reference/core/documents/langchain_core.documents.base.Document.html) 对象列表，这些对象与查询最相关。
用于获取相关文档的底层逻辑由检索器指定，可以是任何对应用程序最有用的逻辑。

LangChain 检索器是一个 [runnable](/docs/how_to/lcel_cheatsheet/)，它是 LangChain 组件的标准接口。 
这意味着它有一些通用方法，包括 `invoke`，用于与之交互。可以使用查询来调用检索器：

```python
docs = retriever.invoke(query)
```

检索器返回一个 [Document](https://python.langchain.com/api_reference/core/documents/langchain_core.documents.base.Document.html) 对象列表，这些对象具有两个属性：

* `page_content`: 此文档的内容。目前是一个字符串。
* `metadata`: 与此文档关联的任意元数据（例如，文档 ID、文件名、来源等）。 

:::info[Further reading]

* 请参阅我们关于构建自定义检索器的[操作指南](/docs/how_to/custom_retriever/)。

:::
 
## Common types

尽管检索器接口具有灵活性，但有几种常见的检索系统类型被频繁使用。

### Search apis

需要注意的是，检索器不一定需要实际*存储*文档。 
例如，我们可以基于搜索 API 构建检索器，这些 API 只返回搜索结果！ 
请参阅我们与 [Amazon Kendra](/docs/integrations/retrievers/amazon_kendra_retriever/) 或 [Wikipedia Search](/docs/integrations/retrievers/wikipedia/) 的检索器集成。 

### Relational or graph database

可以基于关系型或图数据库构建检索器。
在这些情况下，[query analysis](/docs/concepts/retrieval/) 技术用于从自然语言构建结构化查询至关重要。
例如，您可以使用文本到 SQL 转换来构建 SQL 数据库的检索器。这允许在后台将自然语言查询（字符串）检索器转换为 SQL 查询。

:::info[Further reading]

* 请参阅我们的[教程](/docs/tutorials/sql_qa/)，了解如何使用 SQL 数据库和文本到 SQL 构建检索器的背景信息。
* 请参阅我们的[教程](/docs/tutorials/graph/)，了解如何使用图数据库和文本到 Cypher 构建检索器的背景信息。

:::

### Lexical search

正如我们在[检索](/docs/concepts/retrieval/)概念回顾中所讨论的，许多搜索引擎基于将查询中的单词与每个文档中的单词进行匹配。 
[BM25](https://en.wikipedia.org/wiki/Okapi_BM25#:~:text=BM25%20is%20a%20bag%2Dof,slightly%20different%20components%20and%20parameters.) 和 [TF-IDF](https://en.wikipedia.org/wiki/Tf%E2%80%93idf) 是[两种流行的词汇搜索算法](https://cameronrwolfe.substack.com/p/the-basics-of-ai-powered-vector-search?utm_source=profile&utm_medium=reader2)。
LangChain 提供了许多流行的词汇搜索算法/引擎的检索器集成。

:::info[Further reading]

* 请参阅 [BM25](/docs/integrations/retrievers/bm25/) 检索器集成。
* 请参阅 [TF-IDF](/docs/integrations/retrievers/tf_idf/) 检索器集成。
* 请参阅 [Elasticsearch](/docs/integrations/retrievers/elasticsearch_retriever/) 检索器集成。

::: 

### Vector store 

[Vector stores](/docs/concepts/vectorstores/) 是索引和检索非结构化数据的强大而有效的方式。 
可以通过调用 `as_retriever()` 方法将向量存储用作检索器。

```python
vectorstore = MyVectorStore()
retriever = vectorstore.as_retriever()
```

## Advanced retrieval patterns

### Ensemble 

由于检索器接口非常简单，可以通过搜索查询返回 `Document` 对象列表，因此可以使用集成将多个检索器组合起来。
当您拥有多个擅长查找不同类型相关文档的检索器时，这一点尤其有用。
可以轻松创建[集成检索器](/docs/how_to/ensemble_retriever/)，该检索器通过线性加权分数组合多个检索器：

```python
# Initialize the ensemble retriever
ensemble_retriever = EnsembleRetriever(
    retrievers=[bm25_retriever, vector_store_retriever], weights=[0.5, 0.5]
)
```

在集成时，我们如何组合来自多个检索器的搜索结果？ 
这引出了重新排序的概念，该概念接收多个检索器的输出来使用更复杂的算法（如 [Reciprocal Rank Fusion (RRF)](https://plg.uwaterloo.ca/~gvcormac/cormacksigir09-rrf.pdf)）进行组合。

### Source document retention 

许多检索器利用某种索引来使文档易于搜索。
索引过程可能包括转换步骤（例如，向量存储通常使用文档拆分器）。 
无论使用何种转换，保留*转换后的文档*与原始文档之间的链接都非常有用，从而使检索器能够返回*原始*文档。

![Retrieval with full docs](/img/retriever_full_docs.png)

这在 AI 应用中尤其有用，因为它确保了模型在文档上下文方面没有丢失。
例如，您可能在向量存储中为文档编制索引时使用较小的分块大小。 
如果仅将分块作为检索结果返回，那么模型将丢失分块的原始文档上下文。 

LangChain 提供了两种不同的检索器来应对这一挑战。 
[Multi-Vector](/docs/how_to/multi_vector/) 检索器允许用户使用任何文档转换（例如，使用 LLM 为文档编写摘要）进行索引，同时保留与源文档的链接。 
[ParentDocument](/docs/how_to/parent_document_retriever/) 检索器链接来自文本拆分器转换的文档分块以进行索引，同时保留与源文档的链接。 

| Name                                                      | Index Type                    | Uses an LLM               | When to Use                                                                                                                             | Description                                                                                                                                                                                                              |
|-----------------------------------------------------------|-------------------------------|---------------------------|-----------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| [ParentDocument](/docs/how_to/parent_document_retriever/) | Vector store + Document Store | No                        | If your pages have lots of smaller pieces of distinct information that are best indexed by themselves, but best retrieved all together. | This involves indexing multiple chunks for each document. Then you find the chunks that are most similar in embedding space, but you retrieve the whole parent document and return that (rather than individual chunks). |
| [Multi Vector](/docs/how_to/multi_vector/)                | Vector store + Document Store | Sometimes during indexing | If you are able to extract information from documents that you think is more relevant to index than the text itself.                    | This involves creating multiple vectors for each document. Each vector could be created in a myriad of ways - examples include summaries of the text and hypothetical questions.                                         |

:::info[Further reading]

* 请参阅我们关于使用 ParentDocument 检索器的[操作指南](/docs/how_to/parent_document_retriever/)。
* 请参阅我们关于使用 MultiVector 检索器的[操作指南](/docs/how_to/multi_vector/)。
* 请参阅我们关于[多向量检索器](https://youtu.be/gTCU9I6QqCE?feature=shared)的从零开始的 RAG 视频。

:::