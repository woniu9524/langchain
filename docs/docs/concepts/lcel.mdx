# LangChain 表达式语言 (LCEL)

:::info 先决条件
* [Runnable 接口](/docs/concepts/runnables)
:::

**L**ang**C**hain **E**xpression **L**anguage (LCEL) 采用一种[声明式](https://en.wikipedia.org/wiki/Declarative_programming)方法，通过现有的 `Runnable` 来构建新的 `Runnable`。

这意味着你描述的是*应该*发生什么，而不是*如何*发生，这使得 LangChain 能够优化链的运行时执行。

我们经常将使用 LCEL 创建的 `Runnable` 称为“链”。需要记住的是，“链”是一个 `Runnable`，它实现了完整的[Runnable 接口](/docs/concepts/runnables)。

:::note
* [LCEL 备忘单](/docs/how_to/lcel_cheatsheet/) 展示了涉及 Runnable 接口和 LCEL 表达式的常见模式。
* 请参阅以下[如何操作指南](/docs/how_to/#langchain-expression-language-lcel)列表，其中涵盖了 LCEL 的常见任务。
* 可以在[LangChain Core API 参考](https://python.langchain.com/api_reference/core/runnables.html)中找到内置 `Runnable` 的列表。在 LangChain 中使用 LCEL 组合自定义“链”时，许多这些 `Runnable` 都很有用。
:::

## LCEL 的优势

LangChain 以多种方式优化了使用 LCEL 构建的链的运行时执行：

- **优化的并行执行**：使用 [RunnableParallel](#runnableparallel) 并行运行 `Runnable`，或使用 [Runnable Batch API](/docs/concepts/runnables/#optimized-parallel-execution-batch) 并行处理多个输入。并行执行可以显着降低延迟，因为处理可以并行进行而不是顺序进行。
- **保证的异步支持**：使用 [Runnable Async API](/docs/concepts/runnables/#asynchronous-support) 可以异步运行使用 LCEL 构建的任何链。这在服务器环境中运行链时非常有用，因为您希望并发处理大量请求。
- **简化流式传输**：LCEL 链可以流式传输，允许在链执行时进行增量输出。LangChain 可以优化输出的流式传输，以最小化首次令牌时间（从[聊天模型](/docs/concepts/chat_models)或[LLM](/docs/concepts/text_llms)输出的第一个块开始经过的时间）。

其他优势包括：

- [**无缝的 LangSmith 跟踪**](https://docs.smith.langchain.com)
随着链变得越来越复杂，理解每个步骤确切的发生情况变得越来越重要。
使用 LCEL，**所有**步骤都会自动记录到 [LangSmith](https://docs.smith.langchain.com/) 中，以实现最大的可观察性和可调试性。
- **标准 API**：由于所有链都是使用 Runnable 接口构建的，因此可以像使用任何其他 Runnable 一样使用它们。
- [**可使用 LangServe 进行部署**](/docs/concepts/architecture#langserve)：使用 LCEL 构建的链可以部署以用于生产。

## 我应该使用 LCEL 吗？

LCEL 是一个[编排解决方案](https://en.wikipedia.org/wiki/Orchestration_(computing))——它允许 LangChain 以优化的方式处理链的运行时执行。

尽管我们看到用户在生产环境中运行了数百个步骤的链，但我们通常建议将 LCEL 用于更简单的编排任务。当应用程序需要复杂的有状态管理、分支、循环或多个代理时，我们建议用户利用[LangGraph](/docs/concepts/architecture#langgraph)。

在 LangGraph 中，用户定义指定应用程序流程的图。这允许用户在需要 LCEL 的单个节点内继续使用 LCEL，同时易于定义更具可读性和可维护性的复杂编排逻辑。

以下是一些指南：

* 如果你正在进行单个 LLM 调用，则不需要 LCEL；而是直接调用底层的[聊天模型](/docs/concepts/chat_models)。
* 如果你有一个简单的链（例如，prompt + llm + parser，简单的检索设置等），LCEL 是一个不错的选择，前提是你利用了 LCEL 的优势。
* 如果你正在构建一个复杂的链（例如，带有分支、循环、多个代理等），请改用[LangGraph](/docs/concepts/architecture#langgraph)。请记住，你始终可以在 LangGraph 的各个节点内使用 LCEL。

## 组合原语

`LCEL` 链是通过组合现有的 `Runnable` 来构建的。两个主要的组合原语是 [RunnableSequence](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.RunnableSequence.html#langchain_core.runnables.base.RunnableSequence) 和 [RunnableParallel](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.RunnableParallel.html#langchain_core.runnables.base.RunnableParallel)。

许多其他组合原语（例如 [RunnableAssign](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.passthrough.RunnableAssign.html#langchain_core.runnables.passthrough.RunnableAssign)）可以被视为这两个原语的变体。

:::note
你可以在[LangChain Core API 参考](https://python.langchain.com/api_reference/core/runnables.html)中找到所有组合原语的列表。
:::

### RunnableSequence

`RunnableSequence` 是一个组合原语，允许你将多个 `Runnable` 按顺序“链接”起来，其中一个 `Runnable` 的输出作为下一个的输入。

```python
from langchain_core.runnables import RunnableSequence
chain = RunnableSequence([runnable1, runnable2])
```

使用某些输入调用 `chain`：

```python
final_output = chain.invoke(some_input)
```

相当于：

```python
output1 = runnable1.invoke(some_input)
final_output = runnable2.invoke(output1)
```

:::note
`runnable1` 和 `runnable2` 是你想链接在一起的任何 `Runnable` 的占位符。
:::

### RunnableParallel

`RunnableParallel` 是一个组合原语，允许你并行运行多个 `Runnable`，并为每个 `Runnable` 提供相同的输入。

```python
from langchain_core.runnables import RunnableParallel
chain = RunnableParallel({
    "key1": runnable1,
    "key2": runnable2,
})
```

使用某些输入调用 `chain`：

```python
final_output = chain.invoke(some_input)
```

将产生一个 `final_output` 字典，其键与输入字典相同，但值替换为相应 `Runnable` 的输出。

```python
{
    "key1": runnable1.invoke(some_input),
    "key2": runnable2.invoke(some_input),
}
```

请记住，`Runnable` 是并行执行的，因此虽然结果与上面显示的字典推导相同，但执行时间要快得多。

:::note
`RunnableParallel` 支持同步和异步执行（就像所有 `Runnable` 一样）。

* 对于同步执行，`RunnableParallel` 使用 [ThreadPoolExecutor](https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.ThreadPoolExecutor) 并行运行 `Runnable`。
* 对于异步执行，`RunnableParallel` 使用 [asyncio.gather](https://docs.python.org/3/library/asyncio.html#asyncio.gather) 并行运行 `Runnable`。
:::

## 组合语法

`RunnableSequence` 和 `RunnableParallel` 的使用非常普遍，以至于我们为其创建了简写语法。这有助于使代码更具可读性和简洁性。

### `|` 运算符

我们已经[重载](https://docs.python.org/3/reference/datamodel.html#special-method-names)了 `|` 运算符以从两个 `Runnable` 创建 `RunnableSequence`。

```python
chain = runnable1 | runnable2
```

相当于：

```python
chain = RunnableSequence([runnable1, runnable2])
```

### `.pipe` 方法

如果你对运算符重载有任何顾虑，可以使用 `.pipe` 方法代替。这等同于 `|` 运算符。

```python
chain = runnable1.pipe(runnable2)
```

### 类型转换

LCEL 应用自动类型转换，以方便组合链。

如果你不理解类型转换，可以随时直接使用 `RunnableSequence` 和 `RunnableParallel` 类。

这将使代码更冗长，但也会更明确。

#### 字典到 RunnableParallel

在 LCEL 表达式中，字典会自动转换为 `RunnableParallel`。

例如，以下代码：

```python
mapping = {
    "key1": runnable1,
    "key2": runnable2,
}

chain = mapping | runnable3
```

它会自动转换为：

```python
chain = RunnableSequence([RunnableParallel(mapping), runnable3])
```

:::caution
你需要小心，因为 `mapping` 字典不是一个 `RunnableParallel` 对象，它只是一个字典。这意味着以下代码将引发 `AttributeError`：

```python
mapping.invoke(some_input)
```
:::

#### 函数到 RunnableLambda

在 LCEL 表达式中，函数会自动转换为 `RunnableLambda`。

```
def some_func(x):
    return x

chain = some_func | runnable1
```

它会自动转换为：

```python
chain = RunnableSequence([RunnableLambda(some_func), runnable1])
```

:::caution
你需要小心，因为 lambda 函数不是一个 `RunnableLambda` 对象，它只是一个函数。这意味着以下代码将引发 `AttributeError`：

```python
lambda x: x + 1.invoke(some_input)
```
:::

## 旧版链

LCEL 旨在围绕行为和自定义提供一致性，以替代旧的子类化链，如 `LLMChain` 和 `ConversationalRetrievalChain`。其中许多旧版链隐藏了重要的细节，如提示，随着更多可行的模型出现，自定义变得越来越重要。

如果你目前正在使用其中一个旧版链，请参阅[此指南有关如何迁移的说明](/docs/versions/migrating_chains)。

有关使用 LCEL 执行特定任务的指南，请查看[相关操作指南](/docs/how_to/#langchain-expression-language-lcel)。