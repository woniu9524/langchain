---
pagination_next: contributing/how_to/integrations/standard_tests
pagination_prev: contributing/how_to/integrations/index
---
# 如何实现一个集成包

本指南将引导你完成 LangChain 集成包的实现过程。

集成包本质上就是可以通过 `pip install <your-package>` 安装的 Python 包，其中包含与 LangChain 核心接口兼容的类。

我们将涵盖：

1. （可选）如何引导一个新集成包
2. 如何实现遵循 LangChain 接口的组件，例如 [聊天模型](/docs/concepts/chat_models/) 和 [向量存储](/docs/concepts/vectorstores/)；

## （可选）引导一个新集成包

在本节中，我们将概述引导新集成包的两种选项，当然，如果你愿意，也可以使用其他工具！

1. **langchain-cli**：这是一个命令行工具，可用于引导一个包含 LangChain 组件模板和用于依赖管理的 Poetry 的新集成包。
2. **Poetry**：这是一个 Python 依赖管理工具，可用于引导一个新的带依赖关系的 Python 包。然后，你可以向该包添加 LangChain 组件。

<details>
    <summary>选项 1：langchain-cli（推荐）</summary>

在本指南中，我们将使用 `langchain-cli` 从模板创建一个新的集成包，该模板可以进行编辑以实现你的 LangChain 组件。

### **先决条件**

- [GitHub](https://github.com) 账户
- [PyPi](https://pypi.org/) 账户

### 使用 langchain-cli 引导新的 Python 包

首先，安装 `langchain-cli` 和 `poetry`：

```bash
pip install langchain-cli poetry
```

接下来，为你想要创建的包想一个名字。在本指南中，我们将使用 `langchain-parrot-link`。你可以通过在 [PyPi 网站](https://pypi.org/)上搜索来确认该名称是否可用。

然后，使用 `langchain-cli` 创建你的新 Python 包，并使用 `cd` 进入新目录：

```bash
langchain-cli integration new

> 要创建的集成名称（例如 `my-integration`）：parrot-link
> 集成类名称（PascalCase）[ParrotLink]：

cd parrot-link
```

接下来，添加我们需要的任何依赖项：

```bash
poetry add my-integration-sdk
```

我们还可以在单独的 poetry 依赖项组中添加一些 `typing` 或 `test` 依赖项。

```
poetry add --group typing my-typing-dep
poetry add --group test my-test-dep
```

最后，让 poetry 使用你的依赖项和你的集成包设置一个虚拟环境：

```bash
poetry install --with lint,typing,test,test_integration
```

现在你已经拥有了一个包含 LangChain 组件模板的新 Python 包！此模板为每个集成类型都提供了文件，你可以根据需要复制或删除这些文件（包括相关的测试文件）。

要从[模板]创建任何单个文件，你可以运行，例如：

```bash
langchain-cli integration new \
    --name parrot-link \
    --name-class ParrotLink \
    --src integration_template/chat_models.py \
    --dst langchain_parrot_link/chat_models_2.py
```

</details>

<details>
    <summary>选项 2：Poetry（手动）</summary>

在本指南中，我们将使用 [Poetry](https://python-poetry.org/) 进行依赖管理和打包，当然，你也可以使用任何其他你喜欢的工具。

### **先决条件**

- [GitHub](https://github.com) 账户
- [PyPi](https://pypi.org/) 账户

### 使用 Poetry 引导新的 Python 包

首先，安装 Poetry：

```bash
pip install poetry
```

接下来，为你想要创建的包想一个名字。在本指南中，我们将使用 `langchain-parrot-link`。你可以通过在 [PyPi 网站](https://pypi.org/)上搜索来确认该名称是否可用。

然后，使用 Poetry 创建你的新 Python 包，并使用 `cd` 进入新目录：

```bash
poetry new langchain-parrot-link
cd langchain-parrot-link
```

使用 Poetry 添加主要依赖项，这将把它们添加到你的 `pyproject.toml` 文件中：

```bash
poetry add langchain-core
```

我们还将在单独的 poetry 依赖项组中添加一些 `test` 依赖项。如果你不使用 Poetry，我们建议以一种不打包这些依赖项的方式添加它们，或者在运行测试时单独安装它们。

`langchain-tests` 将提供我们稍后将使用的[标准测试](../standard_tests)。我们建议将它们固定到最新版本：<img src="https://img.shields.io/pypi/v/langchain-tests" style={{position:"relative",top:4,left:3}} />

注意：在下面的命令中将 `<latest_version>` 替换为 `langchain-tests` 的最新版本。

```bash
poetry add --group test pytest pytest-socket pytest-asyncio langchain-tests==<latest_version>
```

最后，让 poetry 使用你的依赖项和你的集成包设置一个虚拟环境：

```bash
poetry install --with test
```

你现在已准备好开始编写你的集成包了！

### 编写你的集成

假设你正在构建一个简单的集成包，它为 LangChain 提供了一个 `ChatParrotLink` 聊天模型集成。下面是你的项目结构可能的样子：

```plaintext
langchain-parrot-link/
├── langchain_parrot_link/
│   ├── __init__.py
│   └── chat_models.py
├── tests/
│   ├── __init__.py
│   └── test_chat_models.py
├── pyproject.toml
└── README.md
```

除了 `chat_models.py` 和 `test_chat_models.py` 之外，所有这些文件都应该已经存在于步骤 1 中了！我们将在后面的[标准测试](../standard_tests)指南中实现 `test_chat_models.py`。

对于 `chat_models.py`，只需粘贴聊天模型实现的[内容](#implementing-langchain-components)。

</details>

### 将你的包推送到公共 GitHub 仓库

只有当你想要在 LangChain 文档中发布你的集成时，才需要这样做。

1. 在 GitHub 上创建一个新存储库。
2. 将你的代码推送到该存储库。
3. 确认你的存储库可以被公众查看（例如，在私密浏览窗口中，你未登录 GitHub 时）。

## 实现 LangChain 组件

LangChain 组件是 [langchain-core](/docs/concepts/architecture/#langchain-core) 中基类的子类。示例包括 [聊天模型](/docs/concepts/chat_models/)、[向量存储](/docs/concepts/vectorstores/)、[工具](/docs/concepts/tools/)、[嵌入模型](/docs/concepts/embedding_models/) 和 [检索器](/docs/concepts/retrievers/)。

你的集成包通常会实现至少一个这些组件的子类。展开下面的选项卡以查看每个组件的详细信息。

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';

<Tabs>

    <TabItem value="chat_models" label="聊天模型">
        
        有关启动器聊天模型[实现](/docs/how_to/custom_chat_model/#implementation)的详细信息，请参阅[自定义聊天模型指南](/docs/how_to/custom_chat_model)。

        你可以从以下模板或 langchain-cli 命令开始：

        ```bash
        langchain-cli integration new \
            --name parrot-link \
            --name-class ParrotLink \
            --src integration_template/chat_models.py \
            --dst langchain_parrot_link/chat_models.py
        ```

        <details>
            <summary>示例聊天模型代码</summary>

import ChatModelSource from '../../../../src/theme/integration_template/integration_template/chat_models.py';

        <CodeBlock language="python" title="langchain_parrot_link/chat_models.py">
            {
                ChatModelSource.replaceAll('__ModuleName__', 'ParrotLink')
                    .replaceAll('__package_name__', 'langchain-parrot-link')
                    .replaceAll('__MODULE_NAME__', 'PARROT_LINK')
                    .replaceAll('__module_name__', 'langchain_parrot_link')
            }
        </CodeBlock>

        </details>

    </TabItem>
    <TabItem value="vector_stores" label="向量存储">

你的向量存储实现将取决于你选择的数据库技术。
`langchain-core` 包括一个最小化的
[内存向量存储](https://python.langchain.com/api_reference/core/vectorstores/langchain_core.vectorstores.in_memory.InMemoryVectorStore.html)，
我们可以将其作为参考。你可以在[此处](https://github.com/langchain-ai/langchain/blob/master/libs/core/langchain_core/vectorstores/in_memory.py)访问其代码。

所有向量存储都必须继承自 [VectorStore](https://python.langchain.com/api_reference/core/vectorstores/langchain_core.vectorstores.base.VectorStore.html) 基类。该接口包含用于在向量存储中写入、删除和搜索文档的方法。

`VectorStore` 支持多种同步和异步搜索类型（例如，最近邻搜索或最大边际相关性搜索），以及用于向存储添加文档的接口。有关所有支持的方法，请参阅[API 参考](https://python.langchain.com/api_reference/core/vectorstores/langchain_core.vectorstores.base.VectorStore.html)。下面选项卡中列出了必需的方法：

        | 方法/属性           | 描述                                     |
        |----------------------|------------------------------------------|
        | `add_documents`      | 将文档添加到向量存储。                 |
        | `delete`             | 从向量存储中删除选定的文档（按 ID）。 |
        | `get_by_ids`         | 从向量存储中获取选定的文档（按 ID）。 |
        | `similarity_search`  | 获取与查询最相似的文档。               |
        | `embeddings`（属性） | 向量存储的嵌入对象。                   |
        | `from_texts`         | 通过添加文本来实例化向量存储。         |

请注意，`InMemoryVectorStore` 实现了一些可选的搜索类型，以及用于将对象加载和保存到文件的便捷方法，但并非所有实现都必须如此。

        :::tip

        [内存向量存储](https://github.com/langchain-ai/langchain/blob/master/libs/core/langchain_core/vectorstores/in_memory.py)
        会针对 LangChain GitHub 存储库中的标准测试进行测试。

        :::

        <details>
            <summary>示例向量存储代码</summary>

import VectorstoreSource from '../../../../src/theme/integration_template/integration_template/vectorstores.py';

        <CodeBlock language="python" title="langchain_parrot_link/vectorstores.py">
            {
                VectorstoreSource.replaceAll('__ModuleName__', 'ParrotLink')
                    .replaceAll('__package_name__', 'langchain-parrot-link')
                    .replaceAll('__MODULE_NAME__', 'PARROT_LINK')
                    .replaceAll('__module_name__', 'langchain_parrot_link')
            }
        </CodeBlock>

        </details>

    </TabItem>
    <TabItem value="embeddings" label="嵌入">

嵌入用于将 `Document.page_content` 字段中的 `str` 对象转换为向量表示（表示为浮点数列表）。

有关启动器嵌入[实现](/docs/how_to/custom_embeddings/#implementation)的详细信息，请参阅[自定义嵌入指南](/docs/how_to/custom_embeddings)。

你可以从以下模板或 langchain-cli 命令开始：

```bash
langchain-cli integration new \
    --name parrot-link \
    --name-class ParrotLink \
    --src integration_template/embeddings.py \
    --dst langchain_parrot_link/embeddings.py
```

        <details>
            <summary>示例嵌入代码</summary>

import EmbeddingsSource from '/src/theme/integration_template/integration_template/embeddings.py';

        <CodeBlock language="python" title="langchain_parrot_link/embeddings.py">
            {
                EmbeddingsSource.replaceAll('__ModuleName__', 'ParrotLink')
                    .replaceAll('__package_name__', 'langchain-parrot-link')
                    .replaceAll('__MODULE_NAME__', 'PARROT_LINK')
                    .replaceAll('__module_name__', 'langchain_parrot_link')
            }
        </CodeBlock>

        </details>

    </TabItem>
    <TabItem value="tools" label="工具">

工具主要有两种用法：

1. 定义一个“输入模式”或“参数模式”与文本请求一起传递给聊天模型的工具调用功能，以便聊天模型可以生成一个“工具调用”，或者生成调用该工具的参数。
2. 接收上述生成的“工具调用”，执行某些操作，并返回一个可以作为 `ToolMessage` 传递回聊天模型的响应。

`Tools` 类必须继承自 [BaseTool](https://python.langchain.com/api_reference/core/tools/langchain_core.tools.base.BaseTool.html#langchain_core.tools.base.BaseTool) 基类。该接口有 3 个属性和 2 个方法应在子类中实现。

        | 方法/属性     | 描述                                                              |
        |-----------------|-------------------------------------------------------------------|
        | `name`          | 工具的名称（也传递给 LLM）。                                      |
        | `description`   | 工具的描述（也传递给 LLM）。                                      |
        | `args_schema`   | 定义工具输入参数的模式。                                          |
        | `_run`          | 使用给定参数运行工具。                                            |
        | `_arun`         | 异步运行工具，并使用给定参数。                                  |

### 属性

`name`、`description` 和 `args_schema` 都应该是子类中实现的属性。`name` 和 `description` 是用于标识工具和提供工具作用描述的字符串。这两者都会传递给 LLM，用户可以根据他们使用的 LLM 来覆盖这些值，作为一种“提示工程”形式。为它们赋予简洁且 LLM 可用的名称和描述对于工具的初始用户体验很重要。

`args_schema` 是一个 Pydantic `BaseModel`，用于定义工具输入参数的模式。它用于验证传递给工具的输入参数，并为 LLM 在调用工具时填充提供模式。与整体 Tool 类的 `name` 和 `description` 类似，字段的名称（变量名）和描述（`Field(..., description="description")` 的一部分）会传递给 LLM，这些字段中的值应简洁且 LLM 可用。

### 运行方法

`_run` 是子类中应实现的主要方法。此方法接收来自 `args_schema` 的参数并运行工具，返回一个字符串响应。此方法通常在 LangGraph 的 [`ToolNode`](https://langchain-ai.github.io/langgraph/how-tos/tool-calling/) 中调用，也可以在旧版的 `langchain.agents.AgentExecutor` 中调用。

`_arun` 是可选的，因为默认情况下，`_run` 将在异步执行器中运行。但是，如果你的工具正在调用任何 API 或执行任何异步工作，你应该实现此方法，除了 `_run` 之外，还可以异步运行该工具。

### 实现

你可以从以下模板或 langchain-cli 命令开始：

```bash
langchain-cli integration new \
    --name parrot-link \
    --name-class ParrotLink \
    --src integration_template/tools.py \
    --dst langchain_parrot_link/tools.py
```

        <details>
            <summary>示例工具代码</summary>

import ToolSource from '/src/theme/integration_template/integration_template/tools.py';

        <CodeBlock language="python" title="langchain_parrot_link/tools.py">
            {
                ToolSource.replaceAll('__ModuleName__', 'ParrotLink')
                    .replaceAll('__package_name__', 'langchain-parrot-link')
                    .replaceAll('__MODULE_NAME__', 'PARROT_LINK')
                    .replaceAll('__module_name__', 'langchain_parrot_link')
            }
        </CodeBlock>

        </details>

    </TabItem>
    <TabItem value="retrievers" label="检索器">

检索器用于根据查询从 API、数据库或其他源检索文档。`Retriever` 类必须继承自 [BaseRetriever](https://python.langchain.com/api_reference/core/retrievers/langchain_core.retrievers.BaseRetriever.html) 基类。该接口有 1 个属性和 2 个方法应在子类中实现。

        | 方法/属性         | 描述                                       |
        |--------------------|--------------------------------------------|
        | `k`                | 要检索的默认文档数量（可配置）。         |
        | `_get_relevant_documents`| 根据查询检索文档。                     |
        | `_aget_relevant_documents`| 异步根据查询检索文档。                   |

### 属性

`k` 是子类中应实现的属性。此属性可以简单地在类顶部定义，并带有默认值，例如 `k: int = 5`。此属性是要从检索器检索的文档的默认数量，用户在构造或调用检索器时可以覆盖此值。

### 方法

`_get_relevant_documents` 是子类中应实现的主要方法。

此方法接收一个查询，并返回一个 `Document` 对象列表，这些对象有两个主要属性：

- `page_content` - 文档的文本内容
- `metadata` - 关于文档的元数据的字典

检索器通常由用户直接调用，例如 `MyRetriever(k=4).invoke("query")`，它会在后台自动调用 `_get_relevant_documents`。

`_aget_relevant_documents` 是可选的，因为默认情况下，`_get_relevant_documents` 将在异步执行器中运行。但是，如果你的检索器正在调用任何 API 或执行任何异步工作，你应该实现此方法以异步运行检索器，并为了性能原因而实现 `_get_relevant_documents`。

### 实现

你可以从以下模板或 langchain-cli 命令开始：

```bash
langchain-cli integration new \
    --name parrot-link \
    --name-class ParrotLink \
    --src integration_template/retrievers.py \
    --dst langchain_parrot_link/retrievers.py
```

        <details>
            <summary>示例检索器代码</summary>

import RetrieverSource from '/src/theme/integration_template/integration_template/retrievers.py';

        <CodeBlock language="python" title="langchain_parrot_link/retrievers.py">
            {
                RetrieverSource.replaceAll('__ModuleName__', 'ParrotLink')
                    .replaceAll('__package_name__', 'langchain-parrot-link')
                    .replaceAll('__MODULE_NAME__', 'PARROT_LINK')
                    .replaceAll('__module_name__', 'langchain_parrot_link')
            }
        </CodeBlock>

        </details>

    </TabItem>
</Tabs>

---

## 后续步骤

现在你已经实现了你的包，你可以继续进行[测试你的集成](../standard_tests)，以确保它们能成功运行。